Phase 1: Design & Architecture
  1. Identify Your Core "Nouns" (These become your classes):
    User: Represents someone using the API. Will hold credentials.        
      APIKey / Token: An object that represents a user's authenticated session.    
      APIGateway: The single entry point for all API calls. This is the Facade Pattern. 
      RateLimiter / Throttler: An object responsible for tracking and blocking excessive requests.
      IConnector (Interface): An abstract definition of a connection. This is crucial for your "generic connectivity.
      MockBrokerConnector (Concrete Class): A simulation of a real broker that implements the IConnector interface.
      MarketDataQuery: An object that models your "flight search" data model. It will hold parameters like symbol, startDate, endDate, timeframe.
      TradeOrder: A base class for an order (buy/sell).
      LimitOrder / MarketOrder: Classes that inherit from TradeOrder.
  2. Map Out the Relationships (How classes talk to each other):
    A User "has" credentials.
    An AuthService (another potential class) "validates" a User and "produces" a Token.
    The APIGateway "has" a RateLimiter.
    The APIGateway "has" an IConnector. (This is Dependency Injection).
      The APIGateway "receives" MarketDataQuery and TradeOrder objects from the user.
      The APIGateway "calls" the RateLimiter on every request.
      If the request is allowed, the APIGateway "delegates" the work to the IConnector.
  3. Define Your Interfaces (The "Contracts"): This is the key to your "generic connectivity."
    IConnector Interface:
      connect(credentials)
      disconnect()
      submitOrder(TradeOrder order)
      getMarketData(MarketDataQuery query)
      getAccountBalance()
Phase 2: Implementation
------------------
Phase 3: Integrating the "Flight Search" Data Model
  Your prompt is using "flight search" as an analogy for querying market data. This is a great way to think about it.
  Flight Search: searchFlights(origin, destination, date)
  Market Data: getMarketData(symbol, timeFrame, startDate, endDate)
  You've already defined the MarketDataQuery class in your design. Now, implement it.
  MarketDataQuery Class:
  It should have properties like String symbol (e.g., "AAPL"), String timeFrame (e.g., "1D" for daily), LocalDate startDate, LocalDate endDate.
  MockBrokerConnector Implementation:
  Implement the getMarketData(MarketDataQuery query) method.
  Inside this method, just return fake, hardcoded data.
Phase 4: Testing
  Unit Tests: Use a testing framework (like JUnit for Java or pytest for Python).   
    Test your RateLimiter: Write a test that calls isRequestAllowed 101 times in a loop and asserts that the 101st call returns false.       
    Test your AuthService: Test that a valid login returns a key and an invalid login returns null.       
    Test your APIGateway: This is an integration test.        
      Test 1: Call getMarketData with a bad API key. Assert you get an "Invalid API Key" error.            
      Test 2: Call getMarketData 101 times with a good key. Assert you get a "Rate limit exceeded" error on the last call.            
      Test 3: Call getMarketData with a good key. Assert you get back the fake "AAPL" data from your MockBrokerConnector.    
  Demonstration (Your main method):   
    Create a simple main program that simulates a user.        
    This program will:        
    Create the AuthService, RateLimiter, and MockBrokerConnector.        
    Create the APIGateway, passing those objects into its constructor.    
    Simulate a user logging in to get a key.        
    Simulate the user making a MarketDataQuery (your "flight search").        
    Print the results to the console.
